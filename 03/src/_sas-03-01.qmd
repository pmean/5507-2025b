---
title: "sas-03-01"
format: 
  revealjs:
    slide-number: true
    embed-resources: true
editor: source
---

```{r}
#| message: false
#| warning: false
#| label: 03-01-setup

library(glue)
library(tidyverse)
```

```{r}
#| label: 03-01-read

# Read the program and break it into 
# "bite-sized" pieces that fit easily
# on slides.

read_lines("simon-5507-03-space-delimited.sas") |>
  paste0(collapse="\n") |>
  str_split("\n\n\n") |>
  unlist() |>
  str_remove("^\n") -> sas

add_note <- function(i) {paste0("::: notes\n", sas[i],"\n:::")}
add_code <- function(i) {paste0("```{}\n", sas[i], "\n```")}

text_data <- read_lines("../data/comma-delimited.csv")
```

## Defining a macro variable

-   %let command
    -   defines a macro value
-   &macro_variable_name
    -   substitutes that macro value in the code

::: notes

I find myself switching often between SAS On
Demand for Academics and SAS on Remote Labs.
One thing to simplify the code is to create a
macro variable. A macro variable is a value
that you specify once, typically right at the
start of your program code, and then use 
repeatedly later in your code.

:::

## Simple example

```{}
%let row_limit=10;

(later on in your code)

proc print
    data=phase1(obs=&row_limit);
    
(this gets converted by SAS into)

proc print
    data=phase1(obs=10);
    
```

::: notes

Here's a simple example. You set a macro variable called row_limit equal to the string 10. Then later in your program, you include that macro variable as part of proc print to specify that 

:::

## When should you use a macro variable?

-   Document important options at the top of your program
    -   Quick and easy changes
-   Reduce the amount of repetitive typing

## Text files

-   Each row is a separate observation
-   How to specify individual columns?
    -   Blanks
    -   Delimiters
    -   Fixed width

### Importing choices (1 of 2)
+ A wide range of formats
  + Space delimited
  + Comma separated values
  + Tab delimited
  + Fixed format
+ Strings in your input

<div class="notes">

I want to show a few simple examples of importing data. There are several common formats and SAS can handle all of these easily.

</div>

### Importing choices (2 of 2)
+ proc import
  + First row includes variable names
  + Binary data files
+ Manual reformatting
  + Global search and replace
  + Not usually a good idea
+ Skipping rows
+ Converting strings to numbers

<div class="notes">

Some data sets use the first row to represent variable names while others don't.

If you have to, you can manually reformat the data. Use the global search and replace function in your text editor program. I generally try to avoid this. If your data set changes, you have to redo the reformatting step, which is tedious and error prone. You'd be better off learning a few tricks to get SAS to read a nonstandard data set.

Sometimes you have to skip a few rows. Sometimes you have to convert strings to numbers.

</div>

### Space delimited, example

```{r space-delimited.txt}
opts_current$get("label") %>%
  paste0("../data/", .) %>%
  readLines(warn=FALSE) %>%
  paste0(collapse="\n") %>%
  cat
```

<div class="notes">

You've already imported a file similar to this. It is a space delimited file with one blank between each number. This is the simplest case, and requires very little code.

</div>

### Space delimited, SAS code (1/3)

```{r 5507-03-simon-import-space-delimited.sas}
opts_current$get("label") %>%
  readLines(warn=FALSE) %>%
  str_trim(side="right") %>%
  paste0(collapse="\n") %>% 
  str_split(pattern="\n\n\n") %>%
  unlist -> tx

tx[1] %>% cat
```

<div class="notes">

Here is the SAS code to read and print this file, starting with the documentation header.

</div>

### Space delimited, SAS code (2/3)

```{r}
tx[2] %>% cat
```

<div class="notes">

Here are the lines to tell SAS where everything belongs

</div>

### Space delimited, SAS code (3/3)

```{r}
tx[3] %>% cat
```

<div class="notes">

Here is the rest of the program.

</div>

